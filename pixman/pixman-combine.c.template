#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <math.h>
#include <string.h>

#include "pixman-private.h"

#include "pixman-combine.h"

/*** per channel helper functions ***/

static void
combineMaskC (comp4_t *src, comp4_t *mask)
{
    comp4_t a = *mask;

    comp4_t	x;
    comp2_t	xa;

    if (!a)
    {
	*(src) = 0;
	return;
    }

    x = *(src);
    if (a == ~0)
    {
	x = x >> A_SHIFT;
	x |= x << G_SHIFT;
	x |= x << R_SHIFT;
	*(mask) = x;
	return;
    }

    xa = x >> A_SHIFT;
    UNcx4_MUL_UNcx4(x, a);
    *(src) = x;
    UNcx4_MUL_UNc(a, xa);
    *(mask) = a;
}

static void
combineMaskValueC (comp4_t *src, const comp4_t *mask)
{
    comp4_t a = *mask;
    comp4_t	x;

    if (!a)
    {
	*(src) = 0;
	return;
    }

    if (a == ~0)
	return;

    x = *(src);
    UNcx4_MUL_UNcx4(x, a);
    *(src) =x;
}

static void
combineMaskAlphaC (const comp4_t *src, comp4_t *mask)
{
    comp4_t a = *(mask);
    comp4_t	x;

    if (!a)
	return;

    x = *(src) >> A_SHIFT;
    if (x == MASK)
	return;
    if (a == ~0)
    {
	x = x >> A_SHIFT;
	x |= x << G_SHIFT;
	x |= x << R_SHIFT;
	*(mask) = x;
	return;
    }

    UNcx4_MUL_UNc(a, x);
    *(mask) = a;
}



/*
 * There are two ways of handling alpha -- either as a single unified value or
 * a separate value for each component, hence each macro must have two
 * versions.  The unified alpha version has a 'U' at the end of the name,
 * the component version has a 'C'.  Similarly, functions which deal with
 * this difference will have two versions using the same convention.
 */

/*
 * All of the composing functions
 */

static force_inline comp4_t
combineMask (const comp4_t *src, const comp4_t *mask, int i)
{
    comp4_t s, m;

    if (mask)
    {
	m = *(mask + i) >> A_SHIFT;

	if (!m)
	    return 0;
    }

    s = *(src + i);

    if (mask)
	UNcx4_MUL_UNc (s, m);

    return s;
}

static void
combineClear (pixman_implementation_t *imp, pixman_op_t op,
		comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    memset(dest, 0, width*sizeof(comp4_t));
}

static void
combineSrcU (pixman_implementation_t *imp, pixman_op_t op,
	       comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    int i;

    if (!mask)
	memcpy (dest, src, width * sizeof (comp4_t));
    else
    {
	for (i = 0; i < width; ++i)
	{
	    comp4_t s = combineMask (src, mask, i);
	    
	    *(dest + i) = s;
	}
    }
}

/* if the Src is opaque, call combineSrcU */
static void
combineOverU (pixman_implementation_t *imp, pixman_op_t op,
		comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    int i;
    for (i = 0; i < width; ++i) {
        comp4_t s = combineMask (src, mask, i);
        comp4_t d = *(dest + i);
        comp4_t ia = ALPHA_c(~s);

        UNcx4_MUL_UNc_ADD_UNcx4(d, ia, s);
	*(dest + i) = d;
    }
}

/* if the Dst is opaque, this is a noop */
static void
combineOverReverseU (pixman_implementation_t *imp, pixman_op_t op,
		       comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    int i;
    for (i = 0; i < width; ++i) {
        comp4_t s = combineMask (src, mask, i);
        comp4_t d = *(dest + i);
        comp4_t ia = ALPHA_c(~*(dest + i));
        UNcx4_MUL_UNc_ADD_UNcx4(s, ia, d);
	*(dest + i) = s;
    }
}

/* if the Dst is opaque, call combineSrcU */
static void
combineInU (pixman_implementation_t *imp, pixman_op_t op,
	      comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    int i;
    for (i = 0; i < width; ++i) {
        comp4_t s = combineMask (src, mask, i);
        comp4_t a = ALPHA_c(*(dest + i));
        UNcx4_MUL_UNc(s, a);
	*(dest + i) = s;
    }
}

/* if the Src is opaque, this is a noop */
static void
combineInReverseU (pixman_implementation_t *imp, pixman_op_t op,
		     comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    int i;
    for (i = 0; i < width; ++i) {
	comp4_t s = combineMask (src, mask, i);
	comp4_t d = *(dest + i);
        comp4_t a = ALPHA_c(s);
        UNcx4_MUL_UNc(d, a);
	*(dest + i) = d;
    }
}

/* if the Dst is opaque, call combineClear */
static void
combineOutU (pixman_implementation_t *imp, pixman_op_t op,
	       comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    int i;
    for (i = 0; i < width; ++i) {
        comp4_t s = combineMask (src, mask, i);
        comp4_t a = ALPHA_c(~*(dest + i));
        UNcx4_MUL_UNc(s, a);
	*(dest + i) = s;
    }
}

/* if the Src is opaque, call combineClear */
static void
combineOutReverseU (pixman_implementation_t *imp, pixman_op_t op,
		      comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    int i;
    for (i = 0; i < width; ++i) {
	comp4_t s = combineMask (src, mask, i);
        comp4_t d = *(dest + i);
        comp4_t a = ALPHA_c(~s);
        UNcx4_MUL_UNc(d, a);
	*(dest + i) = d;
    }
}

/* if the Src is opaque, call combineInU */
/* if the Dst is opaque, call combineOverU */
/* if both the Src and Dst are opaque, call combineSrcU */
static void
combineAtopU (pixman_implementation_t *imp, pixman_op_t op,
		comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    int i;
    for (i = 0; i < width; ++i) {
        comp4_t s = combineMask (src, mask, i);
        comp4_t d = *(dest + i);
        comp4_t dest_a = ALPHA_c(d);
        comp4_t src_ia = ALPHA_c(~s);

        UNcx4_MUL_UNc_ADD_UNcx4_MUL_UNc(s, dest_a, d, src_ia);
	*(dest + i) = s;
    }
}

/* if the Src is opaque, call combineOverReverseU */
/* if the Dst is opaque, call combineInReverseU */
/* if both the Src and Dst are opaque, call combineDstU */
static void
combineAtopReverseU (pixman_implementation_t *imp, pixman_op_t op,
		       comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    int i;
    for (i = 0; i < width; ++i) {
        comp4_t s = combineMask (src, mask, i);
        comp4_t d = *(dest + i);
        comp4_t src_a = ALPHA_c(s);
        comp4_t dest_ia = ALPHA_c(~d);

        UNcx4_MUL_UNc_ADD_UNcx4_MUL_UNc(s, dest_ia, d, src_a);
	*(dest + i) = s;
    }
}

/* if the Src is opaque, call combineOverU */
/* if the Dst is opaque, call combineOverReverseU */
/* if both the Src and Dst are opaque, call combineClear */
static void
combineXorU (pixman_implementation_t *imp, pixman_op_t op,
	       comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    int i;
    for (i = 0; i < width; ++i) {
        comp4_t s = combineMask (src, mask, i);
        comp4_t d = *(dest + i);
        comp4_t src_ia = ALPHA_c(~s);
        comp4_t dest_ia = ALPHA_c(~d);

        UNcx4_MUL_UNc_ADD_UNcx4_MUL_UNc(s, dest_ia, d, src_ia);
	*(dest + i) = s;
    }
}

static void
combineAddU (pixman_implementation_t *imp, pixman_op_t op,
	       comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    int i;
    for (i = 0; i < width; ++i) {
        comp4_t s = combineMask (src, mask, i);
        comp4_t d = *(dest + i);
        UNcx4_ADD_UNcx4(d, s);
	*(dest + i) = d;
    }
}

/* if the Src is opaque, call combineAddU */
/* if the Dst is opaque, call combineAddU */
/* if both the Src and Dst are opaque, call combineAddU */
static void
combineSaturateU (pixman_implementation_t *imp, pixman_op_t op,
		    comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    int i;
    for (i = 0; i < width; ++i) {
        comp4_t s = combineMask (src, mask, i);
        comp4_t d = *(dest + i);
        comp2_t sa, da;

        sa = s >> A_SHIFT;
        da = ~d >> A_SHIFT;
        if (sa > da)
        {
            sa = DIV_UNc(da, sa);
            UNcx4_MUL_UNc(s, sa);
        };
        UNcx4_ADD_UNcx4(d, s);
	*(dest + i) = d;
    }
}

/* 
 * PDF blend modes:
 * The following blend modes have been taken from the PDF ISO 32000
 * specification, which at this point in time is available from
 * http://www.adobe.com/devnet/acrobat/pdfs/PDF32000_2008.pdf
 * The relevant chapters are 11.3.5 and 11.3.6.
 * The formula for computing the final pixel color given in 11.3.6 is:
 * αr × Cr = (1 – αs) × αb × Cb + (1 – αb) × αs × Cs + αb × αs × B(Cb, Cs)
 * with B() being the blend function.
 * Note that OVER is a special case of this operation, using B(Cb, Cs) = Cs
 *
 * These blend modes should match the SVG filter draft specification, as 
 * it has been designed to mirror ISO 32000. Note that at the current point
 * no released draft exists that shows this, as the formulas have not been
 * updated yet after the release of ISO 32000.
 *
 * The default implementation here uses the PDF_SEPARABLE_BLEND_MODE and 
 * PDF_NON_SEPARABLE_BLEND_MODE macros, which take the blend function as an 
 * argument. Note that this implementation operates on premultiplied colors,
 * while the PDF specification does not. Therefore the code uses the formula
 * ar.Cra = (1 – as) . Dca + (1 – ad) . Sca + B(Dca, ad, Sca, as)
 */

/* 
 * Multiply
 * B(Dca, ad, Sca, as) = Dca.Sca
 */

static void
combineMultiplyU (pixman_implementation_t *imp, pixman_op_t op,
		    comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    int i;
    for (i = 0; i < width; ++i) {
        comp4_t s = combineMask (src, mask, i);
        comp4_t d = *(dest + i);
	comp4_t ss = s;
        comp4_t src_ia = ALPHA_c (~s);
	comp4_t dest_ia = ALPHA_c (~d);

	UNcx4_MUL_UNc_ADD_UNcx4_MUL_UNc (ss, dest_ia, d, src_ia);
	UNcx4_MUL_UNcx4 (d, s);
	UNcx4_ADD_UNcx4 (d, ss); 	
	*(dest + i) = d;
    }
}

static void
combineMultiplyC (pixman_implementation_t *imp, pixman_op_t op,
                    comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    int i;
    for (i = 0; i < width; ++i) {
        comp4_t m = *(mask + i);
        comp4_t s = *(src + i);
	comp4_t d = *(dest + i);
	comp4_t r = d;
	comp4_t dest_ia = ALPHA_c (~d);

	combineMaskValueC (&s, &m);

	UNcx4_MUL_UNcx4_ADD_UNcx4_MUL_UNc (r, ~m, s, dest_ia);
	UNcx4_MUL_UNcx4 (d, s);
	UNcx4_ADD_UNcx4 (r, d);

	*(dest + i) = r;
    }
}

#define PDF_SEPARABLE_BLEND_MODE(name)		    \
static void					    \
combine ## name ## U (pixman_implementation_t *imp, pixman_op_t op, \
                        comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width) \
{						    \
    int i;					    \
    for (i = 0; i < width; ++i) {		    \
        comp4_t s = combineMask (src, mask, i);     \
        comp4_t d = *(dest + i);		    \
        comp1_t sa = ALPHA_c(s);			    \
        comp1_t isa = ~sa;			    \
        comp1_t da = ALPHA_c(d);	  		    \
        comp1_t ida = ~da;			    \
	comp4_t	result;				    \
						    \
	result = d;				    \
        UNcx4_MUL_UNc_ADD_UNcx4_MUL_UNc(result, isa, s, ida);	    \
						    \
	*(dest + i) = result +			    \
	    (DIV_ONE_UNc (sa * da) << A_SHIFT) +	    \
	    (blend_ ## name (RED_c (d), da, RED_c (s), sa) << R_SHIFT) + \
	    (blend_ ## name (GREEN_c (d), da, GREEN_c (s), sa) << G_SHIFT) + \
	    (blend_ ## name (BLUE_c (d), da, BLUE_c (s), sa)); \
    }						    \
}						    \
						    \
static void				    \
combine ## name ## C (pixman_implementation_t *imp, pixman_op_t op, \
			comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width) \
{						    \
    int i;					    \
    for (i = 0; i < width; ++i) {		    \
	comp4_t m = *(mask + i);		    \
	comp4_t s = *(src + i);                     \
	comp4_t d = *(dest + i);		    \
	comp1_t da = ALPHA_c(d);  		    \
	comp1_t ida = ~da;			    \
	comp4_t result;				    \
						    \
	combineMaskValueC (&s, &m);		    \
						    \
	result = d;				    \
	UNcx4_MUL_UNcx4_ADD_UNcx4_MUL_UNc (result, ~m, s, ida);	    \
						    \
	result +=				    \
	    (DIV_ONE_UNc (ALPHA_c (m) * da) << A_SHIFT) +				\
	    (blend_ ## name (RED_c (d), da, RED_c (s), RED_c (m)) << R_SHIFT) +	\
	    (blend_ ## name (GREEN_c (d), da, GREEN_c (s), GREEN_c (m)) << G_SHIFT) +	\
	    (blend_ ## name (BLUE_c (d), da, BLUE_c (s), BLUE_c (m)));			\
						    \
	*(dest + i) = result;			    \
    }						    \
}

/*
 * Screen
 * B(Dca, ad, Sca, as) = Dca.sa + Sca.da - Dca.Sca
 */

static inline comp4_t
blend_Screen (comp4_t dca, comp4_t da, comp4_t sca, comp4_t sa)
{
  return DIV_ONE_UNc (sca * da + dca * sa - sca * dca);
}

PDF_SEPARABLE_BLEND_MODE (Screen)

/*
 * Overlay
 * B(Dca, ab, Sca, as) = 
 *   if 2.Dca < Da
 *     2.Sca.Dca
 *   otherwise
 *     Sa.Da - 2.(Da - Dca).(Sa - Sca)
 */

static inline comp4_t
blend_Overlay (comp4_t dca, comp4_t da, comp4_t sca, comp4_t sa)
{
    comp4_t rca;

    if (2 * dca < da)
	rca = 2 * sca * dca;
    else
	rca = sa * da - 2 * (da - dca) * (sa - sca);
    return DIV_ONE_UNc (rca);
}

PDF_SEPARABLE_BLEND_MODE (Overlay)

/*
 * Darken
 * B(Dca, ab, Sca, as) = min (Sca.Da, Dca.Sa)
 */

static inline comp4_t
blend_Darken (comp4_t dca, comp4_t da, comp4_t sca, comp4_t sa)
{
    comp4_t s, d;
    
    s = sca * da;
    d = dca * sa;
    return DIV_ONE_UNc (s > d ? d : s);
}

PDF_SEPARABLE_BLEND_MODE (Darken)

/*
 * Lighten
 * B(Dca, ab, Sca, as) = max (Sca.Da, Dca.Sa)
 */

static inline comp4_t
blend_Lighten (comp4_t dca, comp4_t da, comp4_t sca, comp4_t sa)
{
    comp4_t s, d;
    
    s = sca * da;
    d = dca * sa;
    return DIV_ONE_UNc (s > d ? s : d);
}

PDF_SEPARABLE_BLEND_MODE (Lighten)

/*
 * Color dodge
 * B(Dca, ab, Sca, as) = 
 *   if Sca == Sa
 *     (Dca != 0).Sa.Da
 *   otherwise
 *     Da.Sa. min (Dca / Da / (1 - Sca/Sa))
 */ 

static inline comp4_t
blend_ColorDodge (comp4_t dca, comp4_t da, comp4_t sca, comp4_t sa)
{
    if (sca >= sa) {
	return DIV_ONE_UNc (sa * da);
    } else {
	comp4_t rca = dca * sa * sa / (sa - sca);
	return DIV_ONE_UNc (rca > sa * da ? sa * da : rca);
    }
}

PDF_SEPARABLE_BLEND_MODE (ColorDodge)

/*
 * Color burn
 * B(Dca, ab, Sca, as) = 
 *   if Sca. == 0
 *     (Da == Dca).SaDa
 *   otherwise
 *     Sa.Da.(1 - min (1, (1 - Dca/Da).Sa / Sca))
 */

static inline comp4_t
blend_ColorBurn (comp4_t dca, comp4_t da, comp4_t sca, comp4_t sa)
{
    if (sca == 0) {
	return 0;
    } else {
	comp4_t sada = sa * da;
	comp4_t rca = (da - dca) * sa * sa / sca;
	return DIV_ONE_UNc (rca > sada ? 0 : sada - rca);
    }
}

PDF_SEPARABLE_BLEND_MODE (ColorBurn)

/*
 * Hard light
 * B(Dca, ab, Sca, as) = 
 *   if 2.Sca < Sa
 *     2.Sca.Dca
 *   otherwise
 *     Sa.Da - 2.(Da - Dca).(Sa - Sca)
 */
static inline comp4_t
blend_HardLight (comp4_t dca, comp4_t da, comp4_t sca, comp4_t sa)
{
    if (2 * sca < sa)
	return DIV_ONE_UNc (2 * sca * dca);
    else
	return DIV_ONE_UNc (sa * da - 2 * (da - dca) * (sa - sca));
}

PDF_SEPARABLE_BLEND_MODE (HardLight)

/*
 * Soft light
 * B(Dca, ab, Sca, as) = 
 *   if (2.Sca <= Sa)
 *     Dca.(Sa - (1 - Dca/Da).(2.Sca - Sa))
 *   otherwise if Dca.4 <= Da
 *     Dca.(Sa + (2.Sca - Sa).((16.Dca/Da - 12).Dca/Da + 3)
 *   otherwise
 *     (Dca.Sa + (SQRT (Dca/Da).Da - Dca).(2.Sca - Sa))
 */

static inline comp4_t
blend_SoftLight (comp4_t dca_org, comp4_t da_org, comp4_t sca_org, comp4_t sa_org)
{
    double dca = dca_org * (1.0 / MASK);
    double da = da_org * (1.0 / MASK);
    double sca = sca_org * (1.0 / MASK);
    double sa = sa_org * (1.0 / MASK);
    double rca;

    if (2 * sca < sa) {
	if (da == 0)
	    rca = dca * sa;
	else
	    rca = dca * sa - dca * (da - dca) * (sa - 2 * sca) / da;
    } else if (da == 0) {
	rca = 0;
    } else if (4 * dca <= da) {
	rca = dca * sa + (2 * sca - sa) * dca * ((16 * dca / da - 12) * dca / da + 3);
    } else {
	rca = dca * sa + (sqrt (dca * da) - dca) * (2 * sca - sa);
    }
    return rca * MASK + 0.5;
}

PDF_SEPARABLE_BLEND_MODE (SoftLight)

/*
 * Difference
 * B(Dca, ab, Sca, as) = abs (Dca.Sa - Sca.Da)
 */

static inline comp4_t
blend_Difference (comp4_t dca, comp4_t da, comp4_t sca, comp4_t sa)
{
    comp4_t dcasa = dca * sa;
    comp4_t scada = sca * da;

    if (scada < dcasa)
	return DIV_ONE_UNc (dcasa - scada);
    else
	return DIV_ONE_UNc (scada - dcasa);
}

PDF_SEPARABLE_BLEND_MODE (Difference)

/*
 * Exclusion
 * B(Dca, ab, Sca, as) = (Sca.Da + Dca.Sa - 2.Sca.Dca)
 */

/* This can be made faster by writing it directly and not using
 * PDF_SEPARABLE_BLEND_MODE, but that's a performance optimization */

static inline comp4_t
blend_Exclusion (comp4_t dca, comp4_t da, comp4_t sca, comp4_t sa)
{
    return DIV_ONE_UNc (sca * da + dca * sa - 2 * dca * sca);
}

PDF_SEPARABLE_BLEND_MODE (Exclusion)

#undef PDF_SEPARABLE_BLEND_MODE

/*
 * PDF nonseperable blend modes are implemented using the following functions
 * to operate in Hsl space, with Cmax, Cmid, Cmin referring to the max, mid 
 * and min value of the red, green and blue components.
 * 
 * Lum (C) = 0.3 × Cred + 0.59 × Cgreen + 0.11 × Cblue
 *
 * ClipColor (C):
 *   l = Lum (C)
 *   min = Cmin
 *   max = Cmax
 *   if n < 0.0
 *     C = l + ( ( ( C – l ) × l ) ⁄ ( l – min ) )
 *   if x > 1.0
 *     C = l + ( ( ( C – l ) × ( 1 – l ) ) ⁄ ( max – l ) )
 *   return C
 *
 * SetLum (C, l):
 *   d = l – Lum (C)
 *   C += d
 *   return ClipColor (C)
 *
 * Sat (C) = Max (C) - Min (C)
 *
 * SetSat (C, s):
 *  if Cmax > Cmin
 *    Cmid = ( ( ( Cmid – Cmin ) × s ) ⁄ ( Cmax – Cmin ) )
 *    Cmax = s
 *  else
 *    Cmid = Cmax = 0.0
 *  Cmin = 0.0
 *  return C
 */

/* For premultiplied colors, we need to know what happens when C is
 * multiplied by a real number. Lum and Sat are linear:
 *
 *    Lum (r × C) = r × Lum (C)		Sat (r * C) = r * Sat (C)
 *
 * If we extend ClipColor with an extra argument a and change
 *
 *        if x >= 1.0
 *
 * into
 *
 *        if x >= a
 *
 * then ClipColor is also linear:
 *
 *    r * ClipColor (C, a) = ClipColor (rC, ra);
 *
 * for positive r.
 *
 * Similarly, we can extend SetLum with an extra argument that is just passed
 * on to ClipColor:
 *
 *   r * SetLum ( C, l, a)
 *
 *   = r × ClipColor ( C + l - Lum (C), a)
 *
 *   = ClipColor ( r * C + r × l - r * Lum (C), r * a)
 *
 *   = SetLum ( r * C, r * l, r * a)
 *
 * Finally, SetSat:
 *
 *    r * SetSat (C, s) = SetSat (x * C, r * s)
 *
 * The above holds for all non-zero x, because they x'es in the fraction for
 * C_mid cancel out. Specifically, it holds for x = r:
 *
 *    r * SetSat (C, s) = SetSat (rC, rs)
 *  
 */

/* So, for the non-separable PDF blend modes, we have (using s, d for non-premultiplied
 * colors, and S, D for premultiplied:
 *
 *   Color:
 *
 *     a_s * a_d * B(s, d)
 *   = a_s * a_d * SetLum (S/a_s, Lum (D/a_d), 1)
 *   = SetLum (S * a_d, a_s * Lum (D), a_s * a_d)
 *
 *
 *   Luminosity:
 *
 *     a_s * a_d * B(s, d)
 *   = a_s * a_d * SetLum (D/a_d, Lum(S/a_s), 1)
 *   = SetLum (a_s * D, a_d * Lum(S), a_s * a_d)
 *
 *
 *   Saturation:
 *
 *     a_s * a_d * B(s, d)
 *   = a_s * a_d * SetLum (SetSat (D/a_d, Sat (S/a_s)), Lum (D/a_d), 1)
 *   = SetLum (a_s * a_d * SetSat (D/a_d, Sat (S/a_s)), a_s * Lum (D), a_s * a_d)
 *   = SetLum (SetSat (a_s * D, a_d * Sat (S), a_s * Lum (D), a_s * a_d))
 *
 *   Hue:
 *
 *     a_s * a_d * B(s, d)
 *   = a_s * a_d * SetLum (SetSat (S/a_s, Sat (D/a_d)), Lum (D/a_d), 1)
 *   = a_s * a_d * SetLum (SetSat (a_d * S, a_s * Sat (D)), a_s * Lum (D), a_s * a_d)
 *
 */
    
#define Min(c) (c[0] < c[1] ? (c[0] < c[2] ? c[0] : c[2]) : (c[1] < c[2] ? c[1] : c[2]))
#define Max(c) (c[0] > c[1] ? (c[0] > c[2] ? c[0] : c[2]) : (c[1] > c[2] ? c[1] : c[2]))
#define Lum(c) ((c[0] * 30 + c[1] * 59 + c[2] * 11) / 100)
#define Sat(c) (Max (c) - Min (c))

#define PDF_NON_SEPARABLE_BLEND_MODE(name)					\
static void								\
combine ## name ## U (pixman_implementation_t *imp, pixman_op_t op,	\
			comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width) \
{									\
    int i;								\
    for (i = 0; i < width; ++i) {					\
        comp4_t s = combineMask (src, mask, i);				\
        comp4_t d = *(dest + i);					\
        comp1_t sa = ALPHA_c(s);						\
        comp1_t isa = ~sa;						\
        comp1_t da = ALPHA_c(d);						\
        comp1_t ida = ~da;						\
	comp4_t	result;							\
	comp4_t sc[3], dc[3], c[3];					\
									\
	result = d;							\
        UNcx4_MUL_UNc_ADD_UNcx4_MUL_UNc(result, isa, s, ida);				\
	dc[0] = RED_c (d);						\
	sc[0] = RED_c (s);						\
	dc[1] = GREEN_c (d);						\
	sc[1] = GREEN_c (s);						\
	dc[2] = BLUE_c (d);						\
	sc[2] = BLUE_c (s);						\
	blend_ ## name (c, dc, da, sc, sa);				\
									\
	*(dest + i) = result +						\
	    (DIV_ONE_UNc (sa * da) << A_SHIFT) +				\
	    (DIV_ONE_UNc (c[0]) << R_SHIFT) +				\
	    (DIV_ONE_UNc (c[1]) << G_SHIFT) +				\
	    (DIV_ONE_UNc (c[2]));						\
    }									\
}									

static void
SetLum (comp4_t dest[3], comp4_t src[3], comp4_t sa, comp4_t lum)
{
  double a, l, min, max;
  double tmp[3];
  
  a = sa * (1.0 / MASK);
  l = lum * (1.0 / MASK);
  tmp[0] = src[0] * (1.0 / MASK);
  tmp[1] = src[1] * (1.0 / MASK);
  tmp[2] = src[2] * (1.0 / MASK);
  l = l - Lum (tmp);
  tmp[0] += l;
  tmp[1] += l;
  tmp[2] += l;

  /* ClipColor */
  l = Lum (tmp);
  min = Min (tmp);
  max = Max (tmp);

  if (min < 0) {
    tmp[0] = l + (tmp[0] - l) * l / (l - min);
    tmp[1] = l + (tmp[1] - l) * l / (l - min);
    tmp[2] = l + (tmp[2] - l) * l / (l - min);
  }
  if (max > a) {
    tmp[0] = l + (tmp[0] - l) * (a - l) / (max - l);
    tmp[1] = l + (tmp[1] - l) * (a - l) / (max - l);
    tmp[2] = l + (tmp[2] - l) * (a - l) / (max - l);
  }
  dest[0] = tmp[0] * MASK + 0.5;
  dest[1] = tmp[1] * MASK + 0.5;
  dest[2] = tmp[2] * MASK + 0.5;
}

static void
SetSat (comp4_t dest[3], comp4_t src[3], comp4_t sat)
{
  int id[3];
  comp4_t min, max;

  if (src[0] > src[1]) {
    if (src[0] > src[2]) {
      id[0] = 0;
      if (src[1] > src[2]) {
	id[1] = 1;
	id[2] = 2;
      } else {
	id[1] = 2;
	id[2] = 1;
      }
    } else {
      id[0] = 2;
      id[1] = 0;
      id[2] = 1;
    }
  } else {
    if (src[0] > src[2]) {
      id[0] = 1;
      id[1] = 0;
      id[2] = 2;
    } else {
      id[2] = 0;
      if (src[1] > src[2]) {
	id[0] = 1;
	id[1] = 2;
      } else {
	id[0] = 2;
	id[1] = 1;
      }
    }
  }
  max = dest[id[0]];
  min = dest[id[2]];
  if (max > min) {
    dest[id[1]] = (dest[id[1]] - min) * sat / (max - min);
    dest[id[0]] = sat;
    dest[id[2]] = 0;
  } else {
    dest[0] = dest[1] = dest[2] = 0;
  }
}

/*
 * Hue:
 * B(Cb, Cs) = SetLum (SetSat (Cs, Sat (Cb)), Lum (Cb))
 */
static inline void
blend_HslHue (comp4_t c[3], comp4_t dc[3], comp4_t da, comp4_t sc[3], comp4_t sa)
{
    c[0] = sc[0] * da;
    c[1] = sc[1] * da;
    c[2] = sc[2] * da;
    SetSat (c, c, Sat (dc) * sa);
    SetLum (c, c, sa * da, Lum (dc) * sa);
}

PDF_NON_SEPARABLE_BLEND_MODE (HslHue)

/*
 * Saturation:
 * B(Cb, Cs) = SetLum (SetSat (Cb, Sat (Cs)), Lum (Cb))
 */
static inline void
blend_HslSaturation (comp4_t c[3], comp4_t dc[3], comp4_t da, comp4_t sc[3], comp4_t sa)
{
    c[0] = dc[0] * sa;
    c[1] = dc[1] * sa;
    c[2] = dc[2] * sa;
    SetSat (c, c, Sat (sc) * da);
    SetLum (c, c, sa * da, Lum (dc) * sa);
}

PDF_NON_SEPARABLE_BLEND_MODE (HslSaturation)

/*
 * Color:
 * B(Cb, Cs) = SetLum (Cs, Lum (Cb))
 */
static inline void
blend_HslColor (comp4_t c[3], comp4_t dc[3], comp4_t da, comp4_t sc[3], comp4_t sa)
{
    c[0] = sc[0] * da;
    c[1] = sc[1] * da;
    c[2] = sc[2] * da;
    SetLum (c, c, sa * da, Lum (dc) * sa);
}

PDF_NON_SEPARABLE_BLEND_MODE (HslColor)

/*
 * Luminosity:
 * B(Cb, Cs) = SetLum (Cb, Lum (Cs))
 */
static inline void
blend_HslLuminosity (comp4_t c[3], comp4_t dc[3], comp4_t da, comp4_t sc[3], comp4_t sa)
{
    c[0] = dc[0] * sa;
    c[1] = dc[1] * sa;
    c[2] = dc[2] * sa;
    SetLum (c, c, sa * da, Lum (sc) * da);
}

PDF_NON_SEPARABLE_BLEND_MODE (HslLuminosity)

#undef Sat
#undef Lum
#undef Max
#undef Min
#undef PDF_NON_SEPARABLE_BLEND_MODE

/* Overlay
 *
 * All of the disjoint composing functions

 The four entries in the first column indicate what source contributions
 come from each of the four areas of the picture -- areas covered by neither
 A nor B, areas covered only by A, areas covered only by B and finally
 areas covered by both A and B.

 Disjoint			Conjoint
 Fa		Fb		Fa		Fb
 (0,0,0,0)	0		0		0		0
 (0,A,0,A)	1		0		1		0
 (0,0,B,B)	0		1		0		1
 (0,A,B,A)	1		min((1-a)/b,1)	1		max(1-a/b,0)
 (0,A,B,B)	min((1-b)/a,1)	1		max(1-b/a,0)	1
 (0,0,0,A)	max(1-(1-b)/a,0) 0		min(1,b/a)	0
 (0,0,0,B)	0		max(1-(1-a)/b,0) 0		min(a/b,1)
 (0,A,0,0)	min(1,(1-b)/a)	0		max(1-b/a,0)	0
 (0,0,B,0)	0		min(1,(1-a)/b)	0		max(1-a/b,0)
 (0,0,B,A)	max(1-(1-b)/a,0) min(1,(1-a)/b)	 min(1,b/a)	max(1-a/b,0)
 (0,A,0,B)	min(1,(1-b)/a)	max(1-(1-a)/b,0) max(1-b/a,0)	min(1,a/b)
 (0,A,B,0)	min(1,(1-b)/a)	min(1,(1-a)/b)	max(1-b/a,0)	max(1-a/b,0)

*/

#define CombineAOut 1
#define CombineAIn  2
#define CombineBOut 4
#define CombineBIn  8

#define CombineClear	0
#define CombineA	(CombineAOut|CombineAIn)
#define CombineB	(CombineBOut|CombineBIn)
#define CombineAOver	(CombineAOut|CombineBOut|CombineAIn)
#define CombineBOver	(CombineAOut|CombineBOut|CombineBIn)
#define CombineAAtop	(CombineBOut|CombineAIn)
#define CombineBAtop	(CombineAOut|CombineBIn)
#define CombineXor	(CombineAOut|CombineBOut)

/* portion covered by a but not b */
static comp1_t
combineDisjointOutPart (comp1_t a, comp1_t b)
{
    /* min (1, (1-b) / a) */

    b = ~b;		    /* 1 - b */
    if (b >= a)		    /* 1 - b >= a -> (1-b)/a >= 1 */
	return MASK;	    /* 1 */
    return DIV_UNc(b,a);     /* (1-b) / a */
}

/* portion covered by both a and b */
static comp1_t
combineDisjointInPart (comp1_t a, comp1_t b)
{
    /* max (1-(1-b)/a,0) */
    /*  = - min ((1-b)/a - 1, 0) */
    /*  = 1 - min (1, (1-b)/a) */

    b = ~b;		    /* 1 - b */
    if (b >= a)		    /* 1 - b >= a -> (1-b)/a >= 1 */
	return 0;	    /* 1 - 1 */
    return ~DIV_UNc(b,a);    /* 1 - (1-b) / a */
}

/* portion covered by a but not b */
static comp1_t
combineConjointOutPart (comp1_t a, comp1_t b)
{
    /* max (1-b/a,0) */
    /* = 1-min(b/a,1) */

    /* min (1, (1-b) / a) */

    if (b >= a)		    /* b >= a -> b/a >= 1 */
	return 0x00;	    /* 0 */
    return ~DIV_UNc(b,a);    /* 1 - b/a */
}

/* portion covered by both a and b */
static comp1_t
combineConjointInPart (comp1_t a, comp1_t b)
{
    /* min (1,b/a) */

    if (b >= a)		    /* b >= a -> b/a >= 1 */
	return MASK;	    /* 1 */
    return DIV_UNc(b,a);     /* b/a */
}

#define GetComp(v,i)   ((comp2_t) (comp1_t) ((v) >> i))

#define Add(x,y,i,t)   ((t) = GetComp(x,i) + GetComp(y,i),              \
                        (comp4_t) ((comp1_t) ((t) | (0 - ((t) >> G_SHIFT)))) << (i))

#define FbGen(x,y,i,ax,ay,t,u,v) ((t) = (MUL_UNc(GetComp(y,i),ay,(u)) + \
					 MUL_UNc(GetComp(x,i),ax,(v))), \
				  	 (comp4_t) ((comp1_t) ((t) |		\
					 (0 - ((t) >> G_SHIFT)))) << (i))

static void
combineDisjointGeneralU (comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width, comp1_t combine)
{
    int i;
    for (i = 0; i < width; ++i) {
        comp4_t s = combineMask (src, mask, i);
        comp4_t d = *(dest + i);
        comp4_t m,n,o,p;
        comp2_t Fa, Fb, t, u, v;
        comp1_t sa = s >> A_SHIFT;
        comp1_t da = d >> A_SHIFT;

        switch (combine & CombineA) {
        default:
            Fa = 0;
            break;
        case CombineAOut:
            Fa = combineDisjointOutPart (sa, da);
            break;
        case CombineAIn:
            Fa = combineDisjointInPart (sa, da);
            break;
        case CombineA:
            Fa = MASK;
            break;
        }

        switch (combine & CombineB) {
        default:
            Fb = 0;
            break;
        case CombineBOut:
            Fb = combineDisjointOutPart (da, sa);
            break;
        case CombineBIn:
            Fb = combineDisjointInPart (da, sa);
            break;
        case CombineB:
            Fb = MASK;
            break;
        }
        m = FbGen (s,d,0,Fa,Fb,t, u, v);
        n = FbGen (s,d,G_SHIFT,Fa,Fb,t, u, v);
        o = FbGen (s,d,R_SHIFT,Fa,Fb,t, u, v);
        p = FbGen (s,d,A_SHIFT,Fa,Fb,t, u, v);
        s = m|n|o|p;
	*(dest + i) = s;
    }
}

static void
combineDisjointOverU (pixman_implementation_t *imp, pixman_op_t op,
			comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    int i;
    for (i = 0; i < width; ++i) {
        comp4_t s = combineMask (src, mask, i);
        comp2_t a = s >> A_SHIFT;

        if (a != 0x00)
        {
            if (a != MASK)
            {
                comp4_t d = *(dest + i);
                a = combineDisjointOutPart (d >> A_SHIFT, a);
                UNcx4_MUL_UNc_ADD_UNcx4(d, a, s);
                s = d;
            }
	    *(dest + i) = s;
        }
    }
}

static void
combineDisjointInU (pixman_implementation_t *imp, pixman_op_t op,
		      comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    combineDisjointGeneralU (dest, src, mask, width, CombineAIn);
}

static void
combineDisjointInReverseU (pixman_implementation_t *imp, pixman_op_t op,
			     comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    combineDisjointGeneralU (dest, src, mask, width, CombineBIn);
}

static void
combineDisjointOutU (pixman_implementation_t *imp, pixman_op_t op,
		       comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    combineDisjointGeneralU (dest, src, mask, width, CombineAOut);
}

static void
combineDisjointOutReverseU (pixman_implementation_t *imp, pixman_op_t op,
			      comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    combineDisjointGeneralU (dest, src, mask, width, CombineBOut);
}

static void
combineDisjointAtopU (pixman_implementation_t *imp, pixman_op_t op,
			comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    combineDisjointGeneralU (dest, src, mask, width, CombineAAtop);
}

static void
combineDisjointAtopReverseU (pixman_implementation_t *imp, pixman_op_t op,
			       comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    combineDisjointGeneralU (dest, src, mask, width, CombineBAtop);
}

static void
combineDisjointXorU (pixman_implementation_t *imp, pixman_op_t op,
		       comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    combineDisjointGeneralU (dest, src, mask, width, CombineXor);
}

static void
combineConjointGeneralU (comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width, comp1_t combine)
{
    int i;
    for (i = 0; i < width; ++i) {
        comp4_t s = combineMask (src, mask, i);
        comp4_t d = *(dest + i);
        comp4_t m,n,o,p;
        comp2_t Fa, Fb, t, u, v;
        comp1_t sa = s >> A_SHIFT;
        comp1_t da = d >> A_SHIFT;

        switch (combine & CombineA) {
        default:
            Fa = 0;
            break;
        case CombineAOut:
            Fa = combineConjointOutPart (sa, da);
            break;
        case CombineAIn:
            Fa = combineConjointInPart (sa, da);
            break;
        case CombineA:
            Fa = MASK;
            break;
        }

        switch (combine & CombineB) {
        default:
            Fb = 0;
            break;
        case CombineBOut:
            Fb = combineConjointOutPart (da, sa);
            break;
        case CombineBIn:
            Fb = combineConjointInPart (da, sa);
            break;
        case CombineB:
            Fb = MASK;
            break;
        }
        m = FbGen (s,d,0,Fa,Fb,t, u, v);
        n = FbGen (s,d,G_SHIFT,Fa,Fb,t, u, v);
        o = FbGen (s,d,R_SHIFT,Fa,Fb,t, u, v);
        p = FbGen (s,d,A_SHIFT,Fa,Fb,t, u, v);
        s = m|n|o|p;
	*(dest + i) = s;
    }
}

static void
combineConjointOverU (pixman_implementation_t *imp, pixman_op_t op,
			comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    combineConjointGeneralU (dest, src, mask, width, CombineAOver);
}


static void
combineConjointOverReverseU (pixman_implementation_t *imp, pixman_op_t op,
			       comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    combineConjointGeneralU (dest, src, mask, width, CombineBOver);
}


static void
combineConjointInU (pixman_implementation_t *imp, pixman_op_t op,
		      comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    combineConjointGeneralU (dest, src, mask, width, CombineAIn);
}


static void
combineConjointInReverseU (pixman_implementation_t *imp, pixman_op_t op,
			     comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    combineConjointGeneralU (dest, src, mask, width, CombineBIn);
}

static void
combineConjointOutU (pixman_implementation_t *imp, pixman_op_t op,
		       comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    combineConjointGeneralU (dest, src, mask, width, CombineAOut);
}

static void
combineConjointOutReverseU (pixman_implementation_t *imp, pixman_op_t op,
			      comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    combineConjointGeneralU (dest, src, mask, width, CombineBOut);
}

static void
combineConjointAtopU (pixman_implementation_t *imp, pixman_op_t op,
			comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    combineConjointGeneralU (dest, src, mask, width, CombineAAtop);
}

static void
combineConjointAtopReverseU (pixman_implementation_t *imp, pixman_op_t op,
			       comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    combineConjointGeneralU (dest, src, mask, width, CombineBAtop);
}

static void
combineConjointXorU (pixman_implementation_t *imp, pixman_op_t op,
		       comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    combineConjointGeneralU (dest, src, mask, width, CombineXor);
}

/********************************************************************************/
/*************************** Per Channel functions ******************************/
/********************************************************************************/

static void
combineClearC (pixman_implementation_t *imp, pixman_op_t op,
		 comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    memset(dest, 0, width*sizeof(comp4_t));
}

static void
combineSrcC (pixman_implementation_t *imp, pixman_op_t op,
	       comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    int i;

    for (i = 0; i < width; ++i) {
	comp4_t s = *(src + i);
	comp4_t m = *(mask + i);

	combineMaskValueC (&s, &m);

	*(dest) = s;
    }
}

static void
combineOverC (pixman_implementation_t *imp, pixman_op_t op,
		comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    int i;

    for (i = 0; i < width; ++i) {
	comp4_t s = *(src + i);
	comp4_t m = *(mask + i);
	comp4_t a;

	combineMaskC (&s, &m);

	a = ~m;
        if (a != ~0)
        {
            if (a)
            {
                comp4_t d = *(dest + i);
                UNcx4_MUL_UNcx4_ADD_UNcx4(d, a, s);
                s = d;
            }
	    *(dest + i) = s;
        }
    }
}

static void
combineOverReverseC (pixman_implementation_t *imp, pixman_op_t op,
		       comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    int i;

    for (i = 0; i < width; ++i) {
        comp4_t d = *(dest + i);
        comp4_t a = ~d >> A_SHIFT;

        if (a)
        {
            comp4_t s = *(src + i);
	    comp4_t m = *(mask + i);

	    combineMaskValueC (&s, &m);

            if (a != MASK)
            {
                UNcx4_MUL_UNc_ADD_UNcx4(s, a, d);
            }
	    *(dest + i) = s;
        }
    }
}

static void
combineInC (pixman_implementation_t *imp, pixman_op_t op,
	      comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    int i;

    for (i = 0; i < width; ++i) {
        comp4_t d = *(dest + i);
        comp2_t a = d >> A_SHIFT;
        comp4_t s = 0;
        if (a)
        {
	    comp4_t m = *(mask + i);

	    s = *(src + i);
	    combineMaskValueC (&s, &m);
            if (a != MASK)
            {
                UNcx4_MUL_UNc(s, a);
            }
        }
	*(dest + i) = s;
    }
}

static void
combineInReverseC (pixman_implementation_t *imp, pixman_op_t op,
		     comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    int i;

    for (i = 0; i < width; ++i) {
        comp4_t s = *(src + i);
        comp4_t m = *(mask + i);
        comp4_t a;

	combineMaskAlphaC (&s, &m);

	a = m;
        if (a != ~0)
        {
            comp4_t d = 0;
            if (a)
            {
                d = *(dest + i);
                UNcx4_MUL_UNcx4(d, a);
            }
	    *(dest + i) = d;
        }
    }
}

static void
combineOutC (pixman_implementation_t *imp, pixman_op_t op,
	       comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    int i;

    for (i = 0; i < width; ++i) {
        comp4_t d = *(dest + i);
        comp2_t a = ~d >> A_SHIFT;
        comp4_t s = 0;
        if (a)
        {
	    comp4_t m = *(mask + i);

	    s = *(src + i);
	    combineMaskValueC (&s, &m);

            if (a != MASK)
            {
                UNcx4_MUL_UNc(s, a);
            }
        }
	*(dest + i) = s;
    }
}

static void
combineOutReverseC (pixman_implementation_t *imp, pixman_op_t op,
		      comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    int i;

    for (i = 0; i < width; ++i) {
	comp4_t s = *(src + i);
	comp4_t m = *(mask + i);
	comp4_t a;

	combineMaskAlphaC (&s, &m);

        a = ~m;
        if (a != ~0)
        {
            comp4_t d = 0;
            if (a)
            {
                d = *(dest + i);
                UNcx4_MUL_UNcx4(d, a);
            }
	    *(dest + i) = d;
        }
    }
}

static void
combineAtopC (pixman_implementation_t *imp, pixman_op_t op,
		comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    int i;

    for (i = 0; i < width; ++i) {
        comp4_t d = *(dest + i);
        comp4_t s = *(src + i);
        comp4_t m = *(mask + i);
        comp4_t ad;
        comp2_t as = d >> A_SHIFT;

	combineMaskC (&s, &m);

        ad = ~m;

        UNcx4_MUL_UNcx4_ADD_UNcx4_MUL_UNc(d, ad, s, as);
	*(dest + i) = d;
    }
}

static void
combineAtopReverseC (pixman_implementation_t *imp, pixman_op_t op,
		       comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    int i;

    for (i = 0; i < width; ++i) {

        comp4_t d = *(dest + i);
        comp4_t s = *(src + i);
        comp4_t m = *(mask + i);
        comp4_t ad;
        comp2_t as = ~d >> A_SHIFT;

	combineMaskC (&s, &m);

	ad = m;

        UNcx4_MUL_UNcx4_ADD_UNcx4_MUL_UNc(d, ad, s, as);
	*(dest + i) = d;
    }
}

static void
combineXorC (pixman_implementation_t *imp, pixman_op_t op,
	       comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    int i;

    for (i = 0; i < width; ++i) {
        comp4_t d = *(dest + i);
        comp4_t s = *(src + i);
        comp4_t m = *(mask + i);
        comp4_t ad;
        comp2_t as = ~d >> A_SHIFT;

	combineMaskC (&s, &m);

	ad = ~m;

        UNcx4_MUL_UNcx4_ADD_UNcx4_MUL_UNc(d, ad, s, as);
	*(dest + i) = d;
    }
}

static void
combineAddC (pixman_implementation_t *imp, pixman_op_t op,
	       comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    int i;

    for (i = 0; i < width; ++i) {
        comp4_t s = *(src + i);
        comp4_t m = *(mask + i);
        comp4_t d = *(dest + i);

	combineMaskValueC (&s, &m);

        UNcx4_ADD_UNcx4(d, s);
	*(dest + i) = d;
    }
}

static void
combineSaturateC (pixman_implementation_t *imp, pixman_op_t op,
		    comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    int i;

    for (i = 0; i < width; ++i) {
        comp4_t s, d;
        comp2_t sa, sr, sg, sb, da;
        comp2_t t, u, v;
        comp4_t m,n,o,p;

        d = *(dest + i);
        s = *(src + i);
	m = *(mask + i);

	combineMaskC (&s, &m);

        sa = (m >> A_SHIFT);
        sr = (m >> R_SHIFT) & MASK;
        sg = (m >> G_SHIFT) & MASK;
        sb =  m             & MASK;
        da = ~d >> A_SHIFT;

        if (sb <= da)
            m = Add(s,d,0,t);
        else
            m = FbGen (s, d, 0, (da << G_SHIFT) / sb, MASK, t, u, v);

        if (sg <= da)
            n = Add(s,d,G_SHIFT,t);
        else
            n = FbGen (s, d, G_SHIFT, (da << G_SHIFT) / sg, MASK, t, u, v);

        if (sr <= da)
            o = Add(s,d,R_SHIFT,t);
        else
            o = FbGen (s, d, R_SHIFT, (da << G_SHIFT) / sr, MASK, t, u, v);

        if (sa <= da)
            p = Add(s,d,A_SHIFT,t);
        else
            p = FbGen (s, d, A_SHIFT, (da << G_SHIFT) / sa, MASK, t, u, v);

	*(dest + i) = m|n|o|p;
    }
}

static void
combineDisjointGeneralC (comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width, comp1_t combine)
{
    int i;

    for (i = 0; i < width; ++i) {
        comp4_t s, d;
        comp4_t m,n,o,p;
        comp4_t Fa, Fb;
        comp2_t t, u, v;
        comp4_t sa;
        comp1_t da;

        s = *(src + i);
        m = *(mask + i);
        d = *(dest + i);
        da = d >> A_SHIFT;

	combineMaskC (&s, &m);

	sa = m;

        switch (combine & CombineA) {
        default:
            Fa = 0;
            break;
        case CombineAOut:
            m = (comp4_t)combineDisjointOutPart ((comp1_t) (sa >> 0), da);
            n = (comp4_t)combineDisjointOutPart ((comp1_t) (sa >> G_SHIFT), da) << G_SHIFT;
            o = (comp4_t)combineDisjointOutPart ((comp1_t) (sa >> R_SHIFT), da) << R_SHIFT;
            p = (comp4_t)combineDisjointOutPart ((comp1_t) (sa >> A_SHIFT), da) << A_SHIFT;
            Fa = m|n|o|p;
            break;
        case CombineAIn:
            m = (comp4_t)combineDisjointInPart ((comp1_t) (sa >> 0), da);
            n = (comp4_t)combineDisjointInPart ((comp1_t) (sa >> G_SHIFT), da) << G_SHIFT;
            o = (comp4_t)combineDisjointInPart ((comp1_t) (sa >> R_SHIFT), da) << R_SHIFT;
            p = (comp4_t)combineDisjointInPart ((comp1_t) (sa >> A_SHIFT), da) << A_SHIFT;
            Fa = m|n|o|p;
            break;
        case CombineA:
            Fa = ~0;
            break;
        }

        switch (combine & CombineB) {
        default:
            Fb = 0;
            break;
        case CombineBOut:
            m = (comp4_t)combineDisjointOutPart (da, (comp1_t) (sa >> 0));
            n = (comp4_t)combineDisjointOutPart (da, (comp1_t) (sa >> G_SHIFT)) << G_SHIFT;
            o = (comp4_t)combineDisjointOutPart (da, (comp1_t) (sa >> R_SHIFT)) << R_SHIFT;
            p = (comp4_t)combineDisjointOutPart (da, (comp1_t) (sa >> A_SHIFT)) << A_SHIFT;
            Fb = m|n|o|p;
            break;
        case CombineBIn:
            m = (comp4_t)combineDisjointInPart (da, (comp1_t) (sa >> 0));
            n = (comp4_t)combineDisjointInPart (da, (comp1_t) (sa >> G_SHIFT)) << G_SHIFT;
            o = (comp4_t)combineDisjointInPart (da, (comp1_t) (sa >> R_SHIFT)) << R_SHIFT;
            p = (comp4_t)combineDisjointInPart (da, (comp1_t) (sa >> A_SHIFT)) << A_SHIFT;
            Fb = m|n|o|p;
            break;
        case CombineB:
            Fb = ~0;
            break;
        }
        m = FbGen (s,d,0,GetComp(Fa,0),GetComp(Fb,0),t, u, v);
        n = FbGen (s,d,G_SHIFT,GetComp(Fa,G_SHIFT),GetComp(Fb,G_SHIFT),t, u, v);
        o = FbGen (s,d,R_SHIFT,GetComp(Fa,R_SHIFT),GetComp(Fb,R_SHIFT),t, u, v);
        p = FbGen (s,d,A_SHIFT,GetComp(Fa,A_SHIFT),GetComp(Fb,A_SHIFT),t, u, v);
        s = m|n|o|p;
	*(dest + i) = s;
    }
}

static void
combineDisjointOverC (pixman_implementation_t *imp, pixman_op_t op,
			comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    combineDisjointGeneralC (dest, src, mask, width, CombineAOver);
}

static void
combineDisjointInC (pixman_implementation_t *imp, pixman_op_t op,
		      comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    combineDisjointGeneralC (dest, src, mask, width, CombineAIn);
}

static void
combineDisjointInReverseC (pixman_implementation_t *imp, pixman_op_t op,
			     comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    combineDisjointGeneralC (dest, src, mask, width, CombineBIn);
}

static void
combineDisjointOutC (pixman_implementation_t *imp, pixman_op_t op,
		       comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    combineDisjointGeneralC (dest, src, mask, width, CombineAOut);
}

static void
combineDisjointOutReverseC (pixman_implementation_t *imp, pixman_op_t op,
			      comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    combineDisjointGeneralC (dest, src, mask, width, CombineBOut);
}

static void
combineDisjointAtopC (pixman_implementation_t *imp, pixman_op_t op,
			comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    combineDisjointGeneralC (dest, src, mask, width, CombineAAtop);
}

static void
combineDisjointAtopReverseC (pixman_implementation_t *imp, pixman_op_t op,
			       comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    combineDisjointGeneralC (dest, src, mask, width, CombineBAtop);
}

static void
combineDisjointXorC (pixman_implementation_t *imp, pixman_op_t op,
		       comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    combineDisjointGeneralC (dest, src, mask, width, CombineXor);
}

static void
combineConjointGeneralC (comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width, comp1_t combine)
{
    int i;

    for (i = 0; i < width; ++i) {
        comp4_t s, d;
        comp4_t m,n,o,p;
        comp4_t Fa, Fb;
        comp2_t t, u, v;
        comp4_t sa;
        comp1_t da;

        s = *(src + i);
        m = *(mask + i);
        d = *(dest + i);
        da = d >> A_SHIFT;

	combineMaskC (&s, &m);

        sa = m;

        switch (combine & CombineA) {
        default:
            Fa = 0;
            break;
        case CombineAOut:
            m = (comp4_t)combineConjointOutPart ((comp1_t) (sa >> 0), da);
            n = (comp4_t)combineConjointOutPart ((comp1_t) (sa >> G_SHIFT), da) << G_SHIFT;
            o = (comp4_t)combineConjointOutPart ((comp1_t) (sa >> R_SHIFT), da) << R_SHIFT;
            p = (comp4_t)combineConjointOutPart ((comp1_t) (sa >> A_SHIFT), da) << A_SHIFT;
            Fa = m|n|o|p;
            break;
        case CombineAIn:
            m = (comp4_t)combineConjointInPart ((comp1_t) (sa >> 0), da);
            n = (comp4_t)combineConjointInPart ((comp1_t) (sa >> G_SHIFT), da) << G_SHIFT;
            o = (comp4_t)combineConjointInPart ((comp1_t) (sa >> R_SHIFT), da) << R_SHIFT;
            p = (comp4_t)combineConjointInPart ((comp1_t) (sa >> A_SHIFT), da) << A_SHIFT;
            Fa = m|n|o|p;
            break;
        case CombineA:
            Fa = ~0;
            break;
        }

        switch (combine & CombineB) {
        default:
            Fb = 0;
            break;
        case CombineBOut:
            m = (comp4_t)combineConjointOutPart (da, (comp1_t) (sa >> 0));
            n = (comp4_t)combineConjointOutPart (da, (comp1_t) (sa >> G_SHIFT)) << G_SHIFT;
            o = (comp4_t)combineConjointOutPart (da, (comp1_t) (sa >> R_SHIFT)) << R_SHIFT;
            p = (comp4_t)combineConjointOutPart (da, (comp1_t) (sa >> A_SHIFT)) << A_SHIFT;
            Fb = m|n|o|p;
            break;
        case CombineBIn:
            m = (comp4_t)combineConjointInPart (da, (comp1_t) (sa >> 0));
            n = (comp4_t)combineConjointInPart (da, (comp1_t) (sa >> G_SHIFT)) << G_SHIFT;
            o = (comp4_t)combineConjointInPart (da, (comp1_t) (sa >> R_SHIFT)) << R_SHIFT;
            p = (comp4_t)combineConjointInPart (da, (comp1_t) (sa >> A_SHIFT)) << A_SHIFT;
            Fb = m|n|o|p;
            break;
        case CombineB:
            Fb = ~0;
            break;
        }
        m = FbGen (s,d,0,GetComp(Fa,0),GetComp(Fb,0),t, u, v);
        n = FbGen (s,d,G_SHIFT,GetComp(Fa,G_SHIFT),GetComp(Fb,G_SHIFT),t, u, v);
        o = FbGen (s,d,R_SHIFT,GetComp(Fa,R_SHIFT),GetComp(Fb,R_SHIFT),t, u, v);
        p = FbGen (s,d,A_SHIFT,GetComp(Fa,A_SHIFT),GetComp(Fb,A_SHIFT),t, u, v);
        s = m|n|o|p;
	*(dest + i) = s;
    }
}

static void
combineConjointOverC (pixman_implementation_t *imp, pixman_op_t op,
			comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    combineConjointGeneralC (dest, src, mask, width, CombineAOver);
}

static void
combineConjointOverReverseC (pixman_implementation_t *imp, pixman_op_t op,
			       comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    combineConjointGeneralC (dest, src, mask, width, CombineBOver);
}

static void
combineConjointInC (pixman_implementation_t *imp, pixman_op_t op,
		      comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    combineConjointGeneralC (dest, src, mask, width, CombineAIn);
}

static void
combineConjointInReverseC (pixman_implementation_t *imp, pixman_op_t op,
			     comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    combineConjointGeneralC (dest, src, mask, width, CombineBIn);
}

static void
combineConjointOutC (pixman_implementation_t *imp, pixman_op_t op,
		       comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    combineConjointGeneralC (dest, src, mask, width, CombineAOut);
}

static void
combineConjointOutReverseC (pixman_implementation_t *imp, pixman_op_t op,
			      comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    combineConjointGeneralC (dest, src, mask, width, CombineBOut);
}

static void
combineConjointAtopC (pixman_implementation_t *imp, pixman_op_t op,
			comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    combineConjointGeneralC (dest, src, mask, width, CombineAAtop);
}

static void
combineConjointAtopReverseC (pixman_implementation_t *imp, pixman_op_t op,
			       comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    combineConjointGeneralC (dest, src, mask, width, CombineBAtop);
}

static void
combineConjointXorC (pixman_implementation_t *imp, pixman_op_t op,
		       comp4_t *dest, const comp4_t *src, const comp4_t *mask, int width)
{
    combineConjointGeneralC (dest, src, mask, width, CombineXor);
}

void
_pixman_setup_combiner_functions_width (pixman_implementation_t *imp)
{
    /* Unified alpha */
    imp->combine_width[PIXMAN_OP_CLEAR] = combineClear;
    imp->combine_width[PIXMAN_OP_SRC] = combineSrcU;
    /* dest */
    imp->combine_width[PIXMAN_OP_OVER] = combineOverU;
    imp->combine_width[PIXMAN_OP_OVER_REVERSE] = combineOverReverseU;
    imp->combine_width[PIXMAN_OP_IN] = combineInU;
    imp->combine_width[PIXMAN_OP_IN_REVERSE] = combineInReverseU;
    imp->combine_width[PIXMAN_OP_OUT] = combineOutU;
    imp->combine_width[PIXMAN_OP_OUT_REVERSE] = combineOutReverseU;
    imp->combine_width[PIXMAN_OP_ATOP] = combineAtopU;
    imp->combine_width[PIXMAN_OP_ATOP_REVERSE] = combineAtopReverseU;
    imp->combine_width[PIXMAN_OP_XOR] = combineXorU;
    imp->combine_width[PIXMAN_OP_ADD] = combineAddU;
    imp->combine_width[PIXMAN_OP_SATURATE] = combineSaturateU;

    /* Disjoint, unified */
    imp->combine_width[PIXMAN_OP_DISJOINT_CLEAR] = combineClear;
    imp->combine_width[PIXMAN_OP_DISJOINT_SRC] = combineSrcU;
    /* dest */
    imp->combine_width[PIXMAN_OP_DISJOINT_OVER] = combineDisjointOverU;
    imp->combine_width[PIXMAN_OP_DISJOINT_OVER_REVERSE] = combineSaturateU;
    imp->combine_width[PIXMAN_OP_DISJOINT_IN] = combineDisjointInU;
    imp->combine_width[PIXMAN_OP_DISJOINT_IN_REVERSE] = combineDisjointInReverseU;
    imp->combine_width[PIXMAN_OP_DISJOINT_OUT] = combineDisjointOutU;
    imp->combine_width[PIXMAN_OP_DISJOINT_OUT_REVERSE] = combineDisjointOutReverseU;
    imp->combine_width[PIXMAN_OP_DISJOINT_ATOP] = combineDisjointAtopU;
    imp->combine_width[PIXMAN_OP_DISJOINT_ATOP_REVERSE] = combineDisjointAtopReverseU;
    imp->combine_width[PIXMAN_OP_DISJOINT_XOR] = combineDisjointXorU;

    /* Conjoint, unified */
    imp->combine_width[PIXMAN_OP_CONJOINT_CLEAR] = combineClear;
    imp->combine_width[PIXMAN_OP_CONJOINT_SRC] = combineSrcU;
    /* dest */
    imp->combine_width[PIXMAN_OP_CONJOINT_OVER] = combineConjointOverU;
    imp->combine_width[PIXMAN_OP_CONJOINT_OVER_REVERSE] = combineConjointOverReverseU;
    imp->combine_width[PIXMAN_OP_CONJOINT_IN] = combineConjointInU;
    imp->combine_width[PIXMAN_OP_CONJOINT_IN_REVERSE] = combineConjointInReverseU;
    imp->combine_width[PIXMAN_OP_CONJOINT_OUT] = combineConjointOutU;
    imp->combine_width[PIXMAN_OP_CONJOINT_OUT_REVERSE] = combineConjointOutReverseU;
    imp->combine_width[PIXMAN_OP_CONJOINT_ATOP] = combineConjointAtopU;
    imp->combine_width[PIXMAN_OP_CONJOINT_ATOP_REVERSE] = combineConjointAtopReverseU;
    imp->combine_width[PIXMAN_OP_CONJOINT_XOR] = combineConjointXorU;

    imp->combine_width[PIXMAN_OP_MULTIPLY] = combineMultiplyU;
    imp->combine_width[PIXMAN_OP_SCREEN] = combineScreenU;
    imp->combine_width[PIXMAN_OP_OVERLAY] = combineOverlayU;
    imp->combine_width[PIXMAN_OP_DARKEN] = combineDarkenU;
    imp->combine_width[PIXMAN_OP_LIGHTEN] = combineLightenU;
    imp->combine_width[PIXMAN_OP_COLOR_DODGE] = combineColorDodgeU;
    imp->combine_width[PIXMAN_OP_COLOR_BURN] = combineColorBurnU;
    imp->combine_width[PIXMAN_OP_HARD_LIGHT] = combineHardLightU;
    imp->combine_width[PIXMAN_OP_SOFT_LIGHT] = combineSoftLightU;
    imp->combine_width[PIXMAN_OP_DIFFERENCE] = combineDifferenceU;
    imp->combine_width[PIXMAN_OP_EXCLUSION] = combineExclusionU;
    imp->combine_width[PIXMAN_OP_HSL_HUE] = combineHslHueU;
    imp->combine_width[PIXMAN_OP_HSL_SATURATION] = combineHslSaturationU;
    imp->combine_width[PIXMAN_OP_HSL_COLOR] = combineHslColorU;
    imp->combine_width[PIXMAN_OP_HSL_LUMINOSITY] = combineHslLuminosityU;

    /* Component alpha combiners */
    imp->combine_width_ca[PIXMAN_OP_CLEAR] = combineClearC;
    imp->combine_width_ca[PIXMAN_OP_SRC] = combineSrcC;
    /* dest */
    imp->combine_width_ca[PIXMAN_OP_OVER] = combineOverC;
    imp->combine_width_ca[PIXMAN_OP_OVER_REVERSE] = combineOverReverseC;
    imp->combine_width_ca[PIXMAN_OP_IN] = combineInC;
    imp->combine_width_ca[PIXMAN_OP_IN_REVERSE] = combineInReverseC;
    imp->combine_width_ca[PIXMAN_OP_OUT] = combineOutC;
    imp->combine_width_ca[PIXMAN_OP_OUT_REVERSE] = combineOutReverseC;
    imp->combine_width_ca[PIXMAN_OP_ATOP] = combineAtopC;
    imp->combine_width_ca[PIXMAN_OP_ATOP_REVERSE] = combineAtopReverseC;
    imp->combine_width_ca[PIXMAN_OP_XOR] = combineXorC;
    imp->combine_width_ca[PIXMAN_OP_ADD] = combineAddC;
    imp->combine_width_ca[PIXMAN_OP_SATURATE] = combineSaturateC;

    /* Disjoint CA */
    imp->combine_width_ca[PIXMAN_OP_DISJOINT_CLEAR] = combineClearC;
    imp->combine_width_ca[PIXMAN_OP_DISJOINT_SRC] = combineSrcC;
    /* dest */
    imp->combine_width_ca[PIXMAN_OP_DISJOINT_OVER] = combineDisjointOverC;
    imp->combine_width_ca[PIXMAN_OP_DISJOINT_OVER_REVERSE] = combineSaturateC;
    imp->combine_width_ca[PIXMAN_OP_DISJOINT_IN] = combineDisjointInC;
    imp->combine_width_ca[PIXMAN_OP_DISJOINT_IN_REVERSE] = combineDisjointInReverseC;
    imp->combine_width_ca[PIXMAN_OP_DISJOINT_OUT] = combineDisjointOutC;
    imp->combine_width_ca[PIXMAN_OP_DISJOINT_OUT_REVERSE] = combineDisjointOutReverseC;
    imp->combine_width_ca[PIXMAN_OP_DISJOINT_ATOP] = combineDisjointAtopC;
    imp->combine_width_ca[PIXMAN_OP_DISJOINT_ATOP_REVERSE] = combineDisjointAtopReverseC;
    imp->combine_width_ca[PIXMAN_OP_DISJOINT_XOR] = combineDisjointXorC;

    /* Conjoint CA */
    imp->combine_width_ca[PIXMAN_OP_CONJOINT_CLEAR] = combineClearC;
    imp->combine_width_ca[PIXMAN_OP_CONJOINT_SRC] = combineSrcC;
    /* dest */
    imp->combine_width_ca[PIXMAN_OP_CONJOINT_OVER] = combineConjointOverC;
    imp->combine_width_ca[PIXMAN_OP_CONJOINT_OVER_REVERSE] = combineConjointOverReverseC;
    imp->combine_width_ca[PIXMAN_OP_CONJOINT_IN] = combineConjointInC;
    imp->combine_width_ca[PIXMAN_OP_CONJOINT_IN_REVERSE] = combineConjointInReverseC;
    imp->combine_width_ca[PIXMAN_OP_CONJOINT_OUT] = combineConjointOutC;
    imp->combine_width_ca[PIXMAN_OP_CONJOINT_OUT_REVERSE] = combineConjointOutReverseC;
    imp->combine_width_ca[PIXMAN_OP_CONJOINT_ATOP] = combineConjointAtopC;
    imp->combine_width_ca[PIXMAN_OP_CONJOINT_ATOP_REVERSE] = combineConjointAtopReverseC;
    imp->combine_width_ca[PIXMAN_OP_CONJOINT_XOR] = combineConjointXorC;

    imp->combine_width_ca[PIXMAN_OP_MULTIPLY] = combineMultiplyC;
    imp->combine_width_ca[PIXMAN_OP_SCREEN] = combineScreenC;
    imp->combine_width_ca[PIXMAN_OP_OVERLAY] = combineOverlayC;
    imp->combine_width_ca[PIXMAN_OP_DARKEN] = combineDarkenC;
    imp->combine_width_ca[PIXMAN_OP_LIGHTEN] = combineLightenC;
    imp->combine_width_ca[PIXMAN_OP_COLOR_DODGE] = combineColorDodgeC;
    imp->combine_width_ca[PIXMAN_OP_COLOR_BURN] = combineColorBurnC;
    imp->combine_width_ca[PIXMAN_OP_HARD_LIGHT] = combineHardLightC;
    imp->combine_width_ca[PIXMAN_OP_SOFT_LIGHT] = combineSoftLightC;
    imp->combine_width_ca[PIXMAN_OP_DIFFERENCE] = combineDifferenceC;
    imp->combine_width_ca[PIXMAN_OP_EXCLUSION] = combineExclusionC;
    /* It is not clear that these make sense, so leave them out for now */
    imp->combine_width_ca[PIXMAN_OP_HSL_HUE] = NULL;
    imp->combine_width_ca[PIXMAN_OP_HSL_SATURATION] = NULL;
    imp->combine_width_ca[PIXMAN_OP_HSL_COLOR] = NULL;
    imp->combine_width_ca[PIXMAN_OP_HSL_LUMINOSITY] = NULL;
}


